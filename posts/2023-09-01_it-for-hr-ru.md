---
title: IT для HR
description: Сжатый текст, рассчитанный на формирование общего представления про "ландшафт" айти индустрии
---

Ожидается, что читатель(ница)

- уверенный пользователь ПК
- представляет себе устройство ПК на уровне "процессор - оперативная память - накопители - прочие устройства ввода-вывода"

**Текст содержит множество упрощений и неточностей, оправданных и приемлемых с моей точки зрения**

**Причины, по которым компьютер стал универсальным устройством**:

1. **В цифровом виде можно представить любую информацию**
2. **Информация в цифровом виде практически не портится**. Это можно сравнить с текстом - если, например, при переписывании, да и просто при хранении аналоговой магнитофонной аудиозаписи неизбежно добавляются искажения, которые при многократном копировании накапливаются и становятся слышны как шум, то при переписывании текста человек не будет перерисовывать поплывшую букву с дефектами, а запишет ее в том виде, в котором она в алфавите. Информация в цифровом виде состоит из "символов", при передаче-получении информации в цифровых устройствах сигнал округляется до ближайшего из отдельных допустимых значений, кодирующих определенный "символ".
3. **Процессор с "Тьюринг-полной" системой команд позволяет написать программу, осуществляющую любую мыслимую обработку информации** - то есть, такую, которую человек может представить в виде алгоритма. Это делает его максимально "расширяемым" устройством, ограниченным только скоростью процессора, объемом памяти и устройствами ввода-вывода - для добавления новых функций всегда можно дописать программу, лишь бы вышеперечисленного было достаточно для ее выполнения, с приемлемой производительностью и "user experience" в целом

## Языки программирования

- (не языки как таковые) **машинные коды и ассемблер**. Машинные коды - это то, что непосредственно выполняет процессор. По сути просто числа в ячейках памяти, которые кодируют его команды, состоящие из опкода (кода операции) и операндов (чисел, которые являются либо номерами других ячеек памяти, либо просто числами, над которыми выполняется эта операция). То есть, процессор "просто" "идет" по нумерованным ячейкам памяти, выполняя команду за командой подряд (или "перепрыгивая", если очередная команда оказывается командой перехода к другой команде, находящейся по указанному в операнде адресу). Ассемблер - это те же машинные коды, но с заменой численных опкодов на "человеческие" слова, которые указывают их смысл. Вероятность попасть в айти компанию, где об этом будут говорить, практически равна 0, но для общего желательно понимать, что "магия" компьютера сводится к вот этому (ну и к вводу-выводу, конечно). Система команд процессора "проста" с точки зрения реализации электронной схемы процессора, который может их выполнять, но сложна с точки зрения программиста, которому надо в таких командах записать мало-мальски сложный алгоритм. Поэтому, как только мощности компьютеров стали позволять хоть какие-то "излишества", программисты стали "наращивать уровни абстракции", создавая языки программирования, позволяющие записывать алгоритмы на чем-то более похожем на естественный язык (или хотя бы на язык математических задач), и программы-компиляторы для этих языков, которые "переводят" написанные на них программы в машинные коды
- **низкого уровня**: низкого - значит "близко к железу" (см. "стек", в котором железо всегда в самом низу). В них уже есть все основные элементы языка программирования - переменные (вместо номеров ячеек памяти с данными), условные операторы, циклы (вместо инструкций перехода к инструкции в ячейке по адресу, указанному в операнде). Но они не скрывают полностью память машины, позволяя обращаться по адресам ячеек и требуют писать код, который "явным образом" выделяет память под сущности, длина которых. Языки низкого уровня: C, C++, Rust. Эти трое - практически все распространенные в нынешнее время языки низкого уровня. Ядра почти всех распространенных операционных систем написаны на С. Другие сложные высокопроизводительные программы и требующие максимальной оптимизации части сложных программ, такие как кодеки аудио-видео форматов, движки рендеринга трехмерной графики в играх - в основном на С++ и том же С. Ну, и сами компиляторы языков программирования тоже.
- **высокого уровня**: полностью скрывают от программиста устройство памяти компьютера, полностью автоматизируют ее выделение под создаваемые сущности и ее освобождение, когда сущности перестают использоваться. Плата за это - "между" написанными программистом инструкциями программы выполняется код "среды выполнения" (которой у программ на языках низкого уровня нет), который все это делает за программиста, причем часто не так оптимально, как написал бы опытный программист на языке низкого уровня. Языки высокого уровня: Python, JavaScript (не путать с Java, совершенно разные), Java, PHP и другие

## Модульность программного обеспечения

В любой сфере люди стремятся избежать дублирования работы и разграничить ее для оптимального разделения труда. В программировании это закономерно приводит к выделению "общего кода", который выносится в "**функции**" и "**модули**". Функция - это все еще часть определенной программы, в коде которой она находится, а модуль - уже что-то внешнее. Функцию достаточно "вызвать" (при вызове функции программа/компьютер выполняет инструкцию перехода к инструкции по адресу, по которому находится первая инструкция функции, являющаяся ее "точкой входа"). Модуль сначала нужно "загрузить", чтобы его функции стали доступны.

**API (application programming interface)** - это описание того, как программа взаимодействует с модулем (набор функций, которые он предоставляет, со всем, что имеет значение для их использования программой)

**Библиотека** - это практически то же, что и описанный ранее "модуль", но слово "библиотека" обычно подчеркивает, что он является "полностью отдельным проектом" (а не внутренней частью другого, отделенной для удобства). Также в "экосистеме" некоторых языков программирования принято все подряд называть модулями (Python) или библиотеками (C/C++); также см. "кернелспейс и юзерспейс"

**Фреймворк** - это очень большая библиотека, которая или покрывает целую область и/или является как бы "заготовкой, каркасом приложения"

**Стек (архитектура ПО)**: Почти все программы используют библиотеки, многие библиотеки используют другие библиотеки. Эту совокупность обычно представляют визуально в виде эдакой "стопки", в которой каждый компонент, зависящий от другого, "стоит на нем", а на самом вверху программа - эдакий "карлик на плечах великанов". Для таких вещей в индустрии часто используют слово **стек** (англ. стопка)

*Также этим словом называется один из основных способов организации использования памяти в программах - но это другое*

**Платформы (в том числе операционные системы) и приложения**: пользователю (даже если он программист) "полноценного компьютера" (предусматривающего возможность расширения его ПО) нужно, чтобы "пользовательские" программы, решающие какие-то конкретные его задачи, были как-то разграничены и единообразно управлялись (устанавливались, запускались, переключались, удалялись). И были относительно изолированы друг от друга, не мешали работе друг друга. "Платформа" - это какая-то совокупность "базовых" программ и библиотек, для которой можно создавать "приложения" - "пользовательские" программы, которые выполняются "поверх" платформы (см. "стек"), являются чем-то "цельным" с точки зрения пользователя, и которыми платформа позволяет управлять. Базовые "платформы" - это "операционные системы", которые изначально появились как "главные управляющие программы" компьютеров, облегчающие пользователям (которые тогда почти все были программистами или хотя бы сисадминами) управление другими программами, предоставляющие унифицированные API для доступа к ресурсам компьютера, в том числе устройствам ввода-вывода, а также контролирующие доступ программ к ресурсам (во избежание нарушения программами работы друг друга или самой ОС, по ошибке или специально); любая операционная система может считаться "платформой", но некоторые "приложения" для операционных систем сами по себе могут считаться "платформой" для приложений еще более высокого уровня, работающих "поверх них". Например, Windows и GNU/Linux являются ОС и платформами, а браузеры, как Chrome и Firefox, являются приложениями для этих платформ, но в то же время являются платформами для "веб-приложений"

Наиболее распространенные ОС "общего назначения" и немного их истории:
- (важный археологический экспонат) UNIX - древняя операционная система, написанная еще в начале 70х. "Тот самый UNIX" уже давным давно не используется (ноэтонеточно), но стал чем-то вроде Римской империи в мире ОС. Он не был первой ОС, но в нем в определенный момент собрали все значимые решения и добавили новых, настолько удачно, что на два десятка лет (века по меркам компьютерного прогресса в то время) он стал "мировой операционной системой", образцом для создания новых, и все распространенные современные ОС содержат что-то от него. Linux и операционки Apple содержат так много, что их обобщенно называют "никсы", даже время в них хранится в виде числа секунд, прошедших с 1970-01-01.
- Windows: создана Microsoft, сначала в 80х как "графическая оболочка" для максимально убогой операционки MS-DOS, "чтоб графический интерфейс как у Apple" (впрочем, Apple его тоже не сами придумали, а позаимствовали у Xerox Parc, вместе с частью разработчиков); затем полностью переписана в 90х виде Windows NT (с широкими заимствованиями из общего с IBM проекта OS/2, в рамках которого предполагалось создать для IBM PC систему, похожую на UNIX)
- Linux: огромное семейство разных ОС на базе ядра Linux kernel. Сам Linux kernel разработан в начале 90х Линусом Торвальдсом как попытка "воссоздать" UNIX для набиравших популярность компьютеров IBM PC, с использованием наработок проекта GNU Ричарда Столлмана (который имел близкую цель, но для него на первом месте важнее была "свобода ПО", т. е. возможность пользователя изучать и улучшать его без необходимости получения разрешения от владельца; В начале 90х GNU уже имел готовый набор "системных приложений", но их ядро еще совсем не было готово, и Линус их опередил). Из-за свободной лицензии и определенных хороших технических и организациионных решений Linux стал доминировать в тех нишах, где нужен не "готовый продукт", а "каркас с возможностью сделать из него что угодно"
    - GNU/Linux
        - "серверный"
        - "десктопный"
    - Android: та самая мобильная ОС. От Linux там в основном только Linux kernel, остальной "стек" свой.
    - всевозможные embedded системы на базе ядра Linux
- ОС Apple
    - OSX: относительно прямой потомок UNIX
    - iOS: создана как OSX для мобилок

**Привилегированность кода ядра ОС и приложений, керпелспейс и юзерспейс**: одной из особенностей "полноценных компьютеров" c "полноценными операционными системами" является то, что ядро операционной системы и приложения разграничены для надежности и безопасности системы, смягчения требований к "безошибочности" разработчиков приложений. Ядро ОС имеет полный доступ ко всем ресурсам компьютера, код ядра называют **привилегированным**, или **кернелспейс кодом (кодом в пространстве ядра)**; каждый запущенный экземпляр приложения имеет "прямой" доступ только к "своей" области оперативной памяти, которое ему выделила ОС, а ко всем остальным ресурсам приложение получает доступ только через ОС, проверяющую все запросы, код приложения называют **непривилигированным**, или **юзерспейс кодом (кодом в простанстве пользователя)**. Благодаря этому ошибки в приложениях могут нанести ограниченный вред, в том числе легко допускаемые при разработке на языках низкого уровня ошибки, связанные с записью информации по неправильным адресам памяти - при попытке приложения что-либо прочитать или записать вне выделенной ему области памяти ОС остановит приложение (ошибка винды "приложение выполнило недопустимую операцию и будет закрыто"). Ошибки в ядре ОС легко могут привести к общему сбою ("синий экран" в винде - ну, если точнее, "синий экран" все же говорит о том, что сработал предусмотренный разработчиками ядра проверочный код, "отлавливающий" недопустимые состояние, и ОС остановила сама себя во избежание) - но ядро ОС содержит только необходимый код и пишут его программисты, которые макисмально понимают, что они делают. Программистов, которые пишут код ядра ОС, называют **системными** (не путать с администраторами), программистов, которые пишут приложения - **прикладными**.

**Модули ядра ОС (драйверы) и приложений (библиотеки)**: в дополнение ранее написанному про модули и библиотеки, стоит добавить, что в модули ядра ОС принято называть драйверами (в мире Windows любые, в Linux все же общепринят термин "модуль ядра", а слово "драйвер" используется реже и подчеркивает, что это модуль для взаимодействия с каким-то устройством). Модули приложений ОС, если эти модули хранятся как отдельные файлы, принято называть библиотеками.

**SDK (Software Development Kit)**: совокупность инструментов для разработки приложений под определенную платформу. Встречается в основном для "проприетарных" платформ, развитие которых полностью контролируется какой-нибудь коммерческой компанией, которая стремится предоставить "инструментарий для разработки" в "максимально готовом к использованию" виде

## Список предметных областей

| Область        | Основные платформы          | Основные языки                                                                     | Основые библиотеки (помимо платформы) | Описание |
| ---            | ---                         | ---                                                                                | ---                                   | ---      |
| Mobile apps    | Android, iOS                | Java, Kotlin, C/C++ (Android); ObjectiveC (iOS)                                    |                                       ||
| Desktop apps   | Windows, OSX, Linux desktop | C/C++, Java, Python + то же, что и Web front (все); C# (Windows); ObjectiveC (OSX) | Qt (все), Electron (JavaScript); .NET/WPF (C#) ||
| Web back(end)  | Linux server                | PHP, Python, JavaScript, Ruby, Java, SQL                                           | Wordpress (PHP), Django (Python), Node.js (JavaScript) | кусок веб-приложений, работающий на сервере, обычно поверх Linux server |
| Web front(end) | браузеры                    | JavaScript                                                                         | React, Angular, "у фронтендеров каждый месяц новый фреймворк :)" | кусок веб-приложений, работающий в браузере |
| Finance        | Windows, Linux server       | Java                                                                               |||
| Embedded (incl. automotive), driver development | Linux server | C/C++, Python, Java ||
| Desktop gaming | Windows                     | С/C++; "шейдерные языки"                                                           | Unity, Unreal (2 фреймворка которые делят бОльшую часть "рынка"), SDL, DirectX (incl. Direct3D), OpenGL, Vulkan |||
| ML/AI          | Linux server                | Python, CUDA                                                                       | PyTorch, TensorFlow                   | нейросети |

## Кроме программистов

- системный администратор
- DevOps - "системный администратор, администрирующий компьютерные системы, используемые программистами для разработки программ"
